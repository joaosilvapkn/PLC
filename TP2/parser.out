Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declist start funlist entrypoint stmtlist
Rule 2     start -> <empty>
Rule 3     entrypoint -> <empty>
Rule 4     fun -> DEF fun_name ( funargs ) ftype { stmtlist }
Rule 5     fun_name -> ID
Rule 6     ftype -> type
Rule 7     stmt -> PRINT ( expr ) ;
Rule 8     stmt -> PRINTLN ( ) ;
Rule 9     stmt -> PRINTLN ( expr ) ;
Rule 10    stmt -> WHILE new_label ( expr ) jz block
Rule 11    stmt -> IF ( expr ) jz block
Rule 12    stmt -> IF ( expr ) jz block ELSE jmp jz_label block
Rule 13    jmp -> <empty>
Rule 14    jz -> <empty>
Rule 15    jz_label -> <empty>
Rule 16    new_label -> <empty>
Rule 17    var_declare -> VAR ID [ NUM ] type ;
Rule 18    var_declare -> VAR ID [ NUM ] [ NUM ] type ;
Rule 19    var_declare -> VAR ID type = expr ;
Rule 20    var_declare -> VAR ID type ;
Rule 21    stmt -> ID = expr ;
Rule 22    stmt -> expr [ expr ] = expr ;
Rule 23    stmt -> RETURN expr ;
Rule 24    stmt -> RETURN ;
Rule 25    stmt -> expr ;
Rule 26    expr -> INPUT ( )
Rule 27    expr -> STRINGTYPE ( expr )
Rule 28    expr -> INTTYPE ( expr )
Rule 29    expr -> FLOATTYPE ( expr )
Rule 30    expr -> expr + expr
Rule 31    expr -> expr - expr
Rule 32    expr -> expr * expr
Rule 33    expr -> expr / expr
Rule 34    expr -> expr > expr
Rule 35    expr -> expr < expr
Rule 36    expr -> expr GTE expr
Rule 37    expr -> expr LTE expr
Rule 38    expr -> expr EQ expr
Rule 39    expr -> expr NEQ expr
Rule 40    expr -> expr % expr
Rule 41    expr -> expr AND expr
Rule 42    expr -> expr OR expr
Rule 43    expr -> expr $ expr
Rule 44    expr -> ! expr
Rule 45    expr -> - expr
Rule 46    expr -> ID
Rule 47    expr -> expr [ expr ]
Rule 48    expr -> STRING
Rule 49    expr -> NUM
Rule 50    expr -> FLOAT
Rule 51    expr -> ID ( fcall )
Rule 52    expr -> ( expr )
Rule 53    type -> STRINGTYPE
Rule 54    type -> INTTYPE
Rule 55    type -> VOIDTYPE
Rule 56    type -> FLOATTYPE
Rule 57    type -> type [ ]
Rule 58    declist -> declist var_declare
Rule 59    declist -> <empty>
Rule 60    funlist -> funlist fun
Rule 61    funlist -> <empty>
Rule 62    stmtlist -> stmtlist stmt
Rule 63    stmtlist -> <empty>
Rule 64    funargs -> idlist
Rule 65    funargs -> <empty>
Rule 66    idlist -> idlist , ID type
Rule 67    idlist -> ID type
Rule 68    fcall -> exprlist
Rule 69    fcall -> <empty>
Rule 70    exprlist -> exprlist , expr
Rule 71    exprlist -> expr
Rule 72    block -> { stmtlist }
Rule 73    block -> stmt

Terminals, with rules where they appear

!                    : 44
$                    : 43
%                    : 40
(                    : 4 7 8 9 10 11 12 26 27 28 29 51 52
)                    : 4 7 8 9 10 11 12 26 27 28 29 51 52
*                    : 32
+                    : 30
,                    : 66 70
-                    : 31 45
/                    : 33
;                    : 7 8 9 17 18 19 20 21 22 23 24 25
<                    : 35
=                    : 19 21 22
>                    : 34
AND                  : 41
DEF                  : 4
ELSE                 : 12
EQ                   : 38
FLOAT                : 50
FLOATTYPE            : 29 56
GTE                  : 36
ID                   : 5 17 18 19 20 21 46 51 66 67
IF                   : 11 12
INPUT                : 26
INTTYPE              : 28 54
LTE                  : 37
NEQ                  : 39
NUM                  : 17 18 18 49
OR                   : 42
PRINT                : 7
PRINTLN              : 8 9
RETURN               : 23 24
STRING               : 48
STRINGTYPE           : 27 53
VAR                  : 17 18 19 20
VOIDTYPE             : 55
WHILE                : 10
[                    : 17 18 18 22 47 57
]                    : 17 18 18 22 47 57
error                : 
{                    : 4 72
}                    : 4 72

Nonterminals, with rules where they appear

block                : 10 11 12 12
declist              : 1 58
entrypoint           : 1
expr                 : 7 9 10 11 12 19 21 22 22 22 23 25 27 28 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 45 47 47 52 70 71
exprlist             : 68 70
fcall                : 51
ftype                : 4
fun                  : 60
fun_name             : 4
funargs              : 4
funlist              : 1 60
idlist               : 64 66
jmp                  : 12
jz                   : 10 11 12
jz_label             : 12
new_label            : 10
program              : 0
start                : 1
stmt                 : 62 73
stmtlist             : 1 4 62 72
type                 : 6 17 18 19 20 57 66 67
var_declare          : 58

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declist start funlist entrypoint stmtlist
    (58) declist -> . declist var_declare
    (59) declist -> .

    VAR             reduce using rule 59 (declist -> .)
    DEF             reduce using rule 59 (declist -> .)
    PRINT           reduce using rule 59 (declist -> .)
    PRINTLN         reduce using rule 59 (declist -> .)
    WHILE           reduce using rule 59 (declist -> .)
    IF              reduce using rule 59 (declist -> .)
    ID              reduce using rule 59 (declist -> .)
    RETURN          reduce using rule 59 (declist -> .)
    INPUT           reduce using rule 59 (declist -> .)
    STRINGTYPE      reduce using rule 59 (declist -> .)
    INTTYPE         reduce using rule 59 (declist -> .)
    FLOATTYPE       reduce using rule 59 (declist -> .)
    !               reduce using rule 59 (declist -> .)
    -               reduce using rule 59 (declist -> .)
    STRING          reduce using rule 59 (declist -> .)
    NUM             reduce using rule 59 (declist -> .)
    FLOAT           reduce using rule 59 (declist -> .)
    (               reduce using rule 59 (declist -> .)
    $end            reduce using rule 59 (declist -> .)

    program                        shift and go to state 1
    declist                        shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> declist . start funlist entrypoint stmtlist
    (58) declist -> declist . var_declare
    (2) start -> .
    (17) var_declare -> . VAR ID [ NUM ] type ;
    (18) var_declare -> . VAR ID [ NUM ] [ NUM ] type ;
    (19) var_declare -> . VAR ID type = expr ;
    (20) var_declare -> . VAR ID type ;

    DEF             reduce using rule 2 (start -> .)
    PRINT           reduce using rule 2 (start -> .)
    PRINTLN         reduce using rule 2 (start -> .)
    WHILE           reduce using rule 2 (start -> .)
    IF              reduce using rule 2 (start -> .)
    ID              reduce using rule 2 (start -> .)
    RETURN          reduce using rule 2 (start -> .)
    INPUT           reduce using rule 2 (start -> .)
    STRINGTYPE      reduce using rule 2 (start -> .)
    INTTYPE         reduce using rule 2 (start -> .)
    FLOATTYPE       reduce using rule 2 (start -> .)
    !               reduce using rule 2 (start -> .)
    -               reduce using rule 2 (start -> .)
    STRING          reduce using rule 2 (start -> .)
    NUM             reduce using rule 2 (start -> .)
    FLOAT           reduce using rule 2 (start -> .)
    (               reduce using rule 2 (start -> .)
    $end            reduce using rule 2 (start -> .)
    VAR             shift and go to state 5

    start                          shift and go to state 3
    var_declare                    shift and go to state 4

state 3

    (1) program -> declist start . funlist entrypoint stmtlist
    (60) funlist -> . funlist fun
    (61) funlist -> .

    DEF             reduce using rule 61 (funlist -> .)
    PRINT           reduce using rule 61 (funlist -> .)
    PRINTLN         reduce using rule 61 (funlist -> .)
    WHILE           reduce using rule 61 (funlist -> .)
    IF              reduce using rule 61 (funlist -> .)
    ID              reduce using rule 61 (funlist -> .)
    RETURN          reduce using rule 61 (funlist -> .)
    INPUT           reduce using rule 61 (funlist -> .)
    STRINGTYPE      reduce using rule 61 (funlist -> .)
    INTTYPE         reduce using rule 61 (funlist -> .)
    FLOATTYPE       reduce using rule 61 (funlist -> .)
    !               reduce using rule 61 (funlist -> .)
    -               reduce using rule 61 (funlist -> .)
    STRING          reduce using rule 61 (funlist -> .)
    NUM             reduce using rule 61 (funlist -> .)
    FLOAT           reduce using rule 61 (funlist -> .)
    (               reduce using rule 61 (funlist -> .)
    $end            reduce using rule 61 (funlist -> .)

    funlist                        shift and go to state 6

state 4

    (58) declist -> declist var_declare .

    VAR             reduce using rule 58 (declist -> declist var_declare .)
    DEF             reduce using rule 58 (declist -> declist var_declare .)
    PRINT           reduce using rule 58 (declist -> declist var_declare .)
    PRINTLN         reduce using rule 58 (declist -> declist var_declare .)
    WHILE           reduce using rule 58 (declist -> declist var_declare .)
    IF              reduce using rule 58 (declist -> declist var_declare .)
    ID              reduce using rule 58 (declist -> declist var_declare .)
    RETURN          reduce using rule 58 (declist -> declist var_declare .)
    INPUT           reduce using rule 58 (declist -> declist var_declare .)
    STRINGTYPE      reduce using rule 58 (declist -> declist var_declare .)
    INTTYPE         reduce using rule 58 (declist -> declist var_declare .)
    FLOATTYPE       reduce using rule 58 (declist -> declist var_declare .)
    !               reduce using rule 58 (declist -> declist var_declare .)
    -               reduce using rule 58 (declist -> declist var_declare .)
    STRING          reduce using rule 58 (declist -> declist var_declare .)
    NUM             reduce using rule 58 (declist -> declist var_declare .)
    FLOAT           reduce using rule 58 (declist -> declist var_declare .)
    (               reduce using rule 58 (declist -> declist var_declare .)
    $end            reduce using rule 58 (declist -> declist var_declare .)


state 5

    (17) var_declare -> VAR . ID [ NUM ] type ;
    (18) var_declare -> VAR . ID [ NUM ] [ NUM ] type ;
    (19) var_declare -> VAR . ID type = expr ;
    (20) var_declare -> VAR . ID type ;

    ID              shift and go to state 7


state 6

    (1) program -> declist start funlist . entrypoint stmtlist
    (60) funlist -> funlist . fun
    (3) entrypoint -> .
    (4) fun -> . DEF fun_name ( funargs ) ftype { stmtlist }

    PRINT           reduce using rule 3 (entrypoint -> .)
    PRINTLN         reduce using rule 3 (entrypoint -> .)
    WHILE           reduce using rule 3 (entrypoint -> .)
    IF              reduce using rule 3 (entrypoint -> .)
    ID              reduce using rule 3 (entrypoint -> .)
    RETURN          reduce using rule 3 (entrypoint -> .)
    INPUT           reduce using rule 3 (entrypoint -> .)
    STRINGTYPE      reduce using rule 3 (entrypoint -> .)
    INTTYPE         reduce using rule 3 (entrypoint -> .)
    FLOATTYPE       reduce using rule 3 (entrypoint -> .)
    !               reduce using rule 3 (entrypoint -> .)
    -               reduce using rule 3 (entrypoint -> .)
    STRING          reduce using rule 3 (entrypoint -> .)
    NUM             reduce using rule 3 (entrypoint -> .)
    FLOAT           reduce using rule 3 (entrypoint -> .)
    (               reduce using rule 3 (entrypoint -> .)
    $end            reduce using rule 3 (entrypoint -> .)
    DEF             shift and go to state 10

    entrypoint                     shift and go to state 8
    fun                            shift and go to state 9

state 7

    (17) var_declare -> VAR ID . [ NUM ] type ;
    (18) var_declare -> VAR ID . [ NUM ] [ NUM ] type ;
    (19) var_declare -> VAR ID . type = expr ;
    (20) var_declare -> VAR ID . type ;
    (53) type -> . STRINGTYPE
    (54) type -> . INTTYPE
    (55) type -> . VOIDTYPE
    (56) type -> . FLOATTYPE
    (57) type -> . type [ ]

    [               shift and go to state 11
    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15
    FLOATTYPE       shift and go to state 16

    type                           shift and go to state 12

state 8

    (1) program -> declist start funlist entrypoint . stmtlist
    (62) stmtlist -> . stmtlist stmt
    (63) stmtlist -> .

    PRINT           reduce using rule 63 (stmtlist -> .)
    PRINTLN         reduce using rule 63 (stmtlist -> .)
    WHILE           reduce using rule 63 (stmtlist -> .)
    IF              reduce using rule 63 (stmtlist -> .)
    ID              reduce using rule 63 (stmtlist -> .)
    RETURN          reduce using rule 63 (stmtlist -> .)
    INPUT           reduce using rule 63 (stmtlist -> .)
    STRINGTYPE      reduce using rule 63 (stmtlist -> .)
    INTTYPE         reduce using rule 63 (stmtlist -> .)
    FLOATTYPE       reduce using rule 63 (stmtlist -> .)
    !               reduce using rule 63 (stmtlist -> .)
    -               reduce using rule 63 (stmtlist -> .)
    STRING          reduce using rule 63 (stmtlist -> .)
    NUM             reduce using rule 63 (stmtlist -> .)
    FLOAT           reduce using rule 63 (stmtlist -> .)
    (               reduce using rule 63 (stmtlist -> .)
    $end            reduce using rule 63 (stmtlist -> .)

    stmtlist                       shift and go to state 17

state 9

    (60) funlist -> funlist fun .

    DEF             reduce using rule 60 (funlist -> funlist fun .)
    PRINT           reduce using rule 60 (funlist -> funlist fun .)
    PRINTLN         reduce using rule 60 (funlist -> funlist fun .)
    WHILE           reduce using rule 60 (funlist -> funlist fun .)
    IF              reduce using rule 60 (funlist -> funlist fun .)
    ID              reduce using rule 60 (funlist -> funlist fun .)
    RETURN          reduce using rule 60 (funlist -> funlist fun .)
    INPUT           reduce using rule 60 (funlist -> funlist fun .)
    STRINGTYPE      reduce using rule 60 (funlist -> funlist fun .)
    INTTYPE         reduce using rule 60 (funlist -> funlist fun .)
    FLOATTYPE       reduce using rule 60 (funlist -> funlist fun .)
    !               reduce using rule 60 (funlist -> funlist fun .)
    -               reduce using rule 60 (funlist -> funlist fun .)
    STRING          reduce using rule 60 (funlist -> funlist fun .)
    NUM             reduce using rule 60 (funlist -> funlist fun .)
    FLOAT           reduce using rule 60 (funlist -> funlist fun .)
    (               reduce using rule 60 (funlist -> funlist fun .)
    $end            reduce using rule 60 (funlist -> funlist fun .)


state 10

    (4) fun -> DEF . fun_name ( funargs ) ftype { stmtlist }
    (5) fun_name -> . ID

    ID              shift and go to state 19

    fun_name                       shift and go to state 18

state 11

    (17) var_declare -> VAR ID [ . NUM ] type ;
    (18) var_declare -> VAR ID [ . NUM ] [ NUM ] type ;

    NUM             shift and go to state 20


state 12

    (19) var_declare -> VAR ID type . = expr ;
    (20) var_declare -> VAR ID type . ;
    (57) type -> type . [ ]

    =               shift and go to state 21
    ;               shift and go to state 22
    [               shift and go to state 23


state 13

    (53) type -> STRINGTYPE .

    =               reduce using rule 53 (type -> STRINGTYPE .)
    ;               reduce using rule 53 (type -> STRINGTYPE .)
    [               reduce using rule 53 (type -> STRINGTYPE .)
    ,               reduce using rule 53 (type -> STRINGTYPE .)
    )               reduce using rule 53 (type -> STRINGTYPE .)
    {               reduce using rule 53 (type -> STRINGTYPE .)


state 14

    (54) type -> INTTYPE .

    =               reduce using rule 54 (type -> INTTYPE .)
    ;               reduce using rule 54 (type -> INTTYPE .)
    [               reduce using rule 54 (type -> INTTYPE .)
    ,               reduce using rule 54 (type -> INTTYPE .)
    )               reduce using rule 54 (type -> INTTYPE .)
    {               reduce using rule 54 (type -> INTTYPE .)


state 15

    (55) type -> VOIDTYPE .

    =               reduce using rule 55 (type -> VOIDTYPE .)
    ;               reduce using rule 55 (type -> VOIDTYPE .)
    [               reduce using rule 55 (type -> VOIDTYPE .)
    ,               reduce using rule 55 (type -> VOIDTYPE .)
    )               reduce using rule 55 (type -> VOIDTYPE .)
    {               reduce using rule 55 (type -> VOIDTYPE .)


state 16

    (56) type -> FLOATTYPE .

    =               reduce using rule 56 (type -> FLOATTYPE .)
    ;               reduce using rule 56 (type -> FLOATTYPE .)
    [               reduce using rule 56 (type -> FLOATTYPE .)
    ,               reduce using rule 56 (type -> FLOATTYPE .)
    )               reduce using rule 56 (type -> FLOATTYPE .)
    {               reduce using rule 56 (type -> FLOATTYPE .)


state 17

    (1) program -> declist start funlist entrypoint stmtlist .
    (62) stmtlist -> stmtlist . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . PRINTLN ( expr ) ;
    (10) stmt -> . WHILE new_label ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block
    (12) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (21) stmt -> . ID = expr ;
    (22) stmt -> . expr [ expr ] = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . expr ;
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    $end            reduce using rule 1 (program -> declist start funlist entrypoint stmtlist .)
    PRINT           shift and go to state 25
    PRINTLN         shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30
    ID              shift and go to state 31
    RETURN          shift and go to state 32
    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    stmt                           shift and go to state 24
    expr                           shift and go to state 27

state 18

    (4) fun -> DEF fun_name . ( funargs ) ftype { stmtlist }

    (               shift and go to state 42


state 19

    (5) fun_name -> ID .

    (               reduce using rule 5 (fun_name -> ID .)


state 20

    (17) var_declare -> VAR ID [ NUM . ] type ;
    (18) var_declare -> VAR ID [ NUM . ] [ NUM ] type ;

    ]               shift and go to state 43


state 21

    (19) var_declare -> VAR ID type = . expr ;
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 45

state 22

    (20) var_declare -> VAR ID type ; .

    VAR             reduce using rule 20 (var_declare -> VAR ID type ; .)
    DEF             reduce using rule 20 (var_declare -> VAR ID type ; .)
    PRINT           reduce using rule 20 (var_declare -> VAR ID type ; .)
    PRINTLN         reduce using rule 20 (var_declare -> VAR ID type ; .)
    WHILE           reduce using rule 20 (var_declare -> VAR ID type ; .)
    IF              reduce using rule 20 (var_declare -> VAR ID type ; .)
    ID              reduce using rule 20 (var_declare -> VAR ID type ; .)
    RETURN          reduce using rule 20 (var_declare -> VAR ID type ; .)
    INPUT           reduce using rule 20 (var_declare -> VAR ID type ; .)
    STRINGTYPE      reduce using rule 20 (var_declare -> VAR ID type ; .)
    INTTYPE         reduce using rule 20 (var_declare -> VAR ID type ; .)
    FLOATTYPE       reduce using rule 20 (var_declare -> VAR ID type ; .)
    !               reduce using rule 20 (var_declare -> VAR ID type ; .)
    -               reduce using rule 20 (var_declare -> VAR ID type ; .)
    STRING          reduce using rule 20 (var_declare -> VAR ID type ; .)
    NUM             reduce using rule 20 (var_declare -> VAR ID type ; .)
    FLOAT           reduce using rule 20 (var_declare -> VAR ID type ; .)
    (               reduce using rule 20 (var_declare -> VAR ID type ; .)
    $end            reduce using rule 20 (var_declare -> VAR ID type ; .)


state 23

    (57) type -> type [ . ]

    ]               shift and go to state 46


state 24

    (62) stmtlist -> stmtlist stmt .

    PRINT           reduce using rule 62 (stmtlist -> stmtlist stmt .)
    PRINTLN         reduce using rule 62 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 62 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 62 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 62 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 62 (stmtlist -> stmtlist stmt .)
    INPUT           reduce using rule 62 (stmtlist -> stmtlist stmt .)
    STRINGTYPE      reduce using rule 62 (stmtlist -> stmtlist stmt .)
    INTTYPE         reduce using rule 62 (stmtlist -> stmtlist stmt .)
    FLOATTYPE       reduce using rule 62 (stmtlist -> stmtlist stmt .)
    !               reduce using rule 62 (stmtlist -> stmtlist stmt .)
    -               reduce using rule 62 (stmtlist -> stmtlist stmt .)
    STRING          reduce using rule 62 (stmtlist -> stmtlist stmt .)
    NUM             reduce using rule 62 (stmtlist -> stmtlist stmt .)
    FLOAT           reduce using rule 62 (stmtlist -> stmtlist stmt .)
    (               reduce using rule 62 (stmtlist -> stmtlist stmt .)
    $end            reduce using rule 62 (stmtlist -> stmtlist stmt .)
    }               reduce using rule 62 (stmtlist -> stmtlist stmt .)


state 25

    (7) stmt -> PRINT . ( expr ) ;

    (               shift and go to state 47


state 26

    (52) expr -> ( . expr )
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 48

state 27

    (22) stmt -> expr . [ expr ] = expr ;
    (25) stmt -> expr . ;
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               shift and go to state 49
    ;               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64


state 28

    (8) stmt -> PRINTLN . ( ) ;
    (9) stmt -> PRINTLN . ( expr ) ;

    (               shift and go to state 65


state 29

    (10) stmt -> WHILE . new_label ( expr ) jz block
    (16) new_label -> .

    (               reduce using rule 16 (new_label -> .)

    new_label                      shift and go to state 66

state 30

    (11) stmt -> IF . ( expr ) jz block
    (12) stmt -> IF . ( expr ) jz block ELSE jmp jz_label block

    (               shift and go to state 67


state 31

    (21) stmt -> ID . = expr ;
    (46) expr -> ID .
    (51) expr -> ID . ( fcall )

    =               shift and go to state 68
    [               reduce using rule 46 (expr -> ID .)
    ;               reduce using rule 46 (expr -> ID .)
    +               reduce using rule 46 (expr -> ID .)
    -               reduce using rule 46 (expr -> ID .)
    *               reduce using rule 46 (expr -> ID .)
    /               reduce using rule 46 (expr -> ID .)
    >               reduce using rule 46 (expr -> ID .)
    <               reduce using rule 46 (expr -> ID .)
    GTE             reduce using rule 46 (expr -> ID .)
    LTE             reduce using rule 46 (expr -> ID .)
    EQ              reduce using rule 46 (expr -> ID .)
    NEQ             reduce using rule 46 (expr -> ID .)
    %               reduce using rule 46 (expr -> ID .)
    AND             reduce using rule 46 (expr -> ID .)
    OR              reduce using rule 46 (expr -> ID .)
    $               reduce using rule 46 (expr -> ID .)
    (               shift and go to state 69


state 32

    (23) stmt -> RETURN . expr ;
    (24) stmt -> RETURN . ;
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    ;               shift and go to state 71
    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 70

state 33

    (26) expr -> INPUT . ( )

    (               shift and go to state 72


state 34

    (27) expr -> STRINGTYPE . ( expr )

    (               shift and go to state 73


state 35

    (28) expr -> INTTYPE . ( expr )

    (               shift and go to state 74


state 36

    (29) expr -> FLOATTYPE . ( expr )

    (               shift and go to state 75


state 37

    (45) expr -> - . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 76

state 38

    (44) expr -> ! . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 77

state 39

    (48) expr -> STRING .

    [               reduce using rule 48 (expr -> STRING .)
    ;               reduce using rule 48 (expr -> STRING .)
    +               reduce using rule 48 (expr -> STRING .)
    -               reduce using rule 48 (expr -> STRING .)
    *               reduce using rule 48 (expr -> STRING .)
    /               reduce using rule 48 (expr -> STRING .)
    >               reduce using rule 48 (expr -> STRING .)
    <               reduce using rule 48 (expr -> STRING .)
    GTE             reduce using rule 48 (expr -> STRING .)
    LTE             reduce using rule 48 (expr -> STRING .)
    EQ              reduce using rule 48 (expr -> STRING .)
    NEQ             reduce using rule 48 (expr -> STRING .)
    %               reduce using rule 48 (expr -> STRING .)
    AND             reduce using rule 48 (expr -> STRING .)
    OR              reduce using rule 48 (expr -> STRING .)
    $               reduce using rule 48 (expr -> STRING .)
    )               reduce using rule 48 (expr -> STRING .)
    ]               reduce using rule 48 (expr -> STRING .)
    ,               reduce using rule 48 (expr -> STRING .)


state 40

    (49) expr -> NUM .

    [               reduce using rule 49 (expr -> NUM .)
    ;               reduce using rule 49 (expr -> NUM .)
    +               reduce using rule 49 (expr -> NUM .)
    -               reduce using rule 49 (expr -> NUM .)
    *               reduce using rule 49 (expr -> NUM .)
    /               reduce using rule 49 (expr -> NUM .)
    >               reduce using rule 49 (expr -> NUM .)
    <               reduce using rule 49 (expr -> NUM .)
    GTE             reduce using rule 49 (expr -> NUM .)
    LTE             reduce using rule 49 (expr -> NUM .)
    EQ              reduce using rule 49 (expr -> NUM .)
    NEQ             reduce using rule 49 (expr -> NUM .)
    %               reduce using rule 49 (expr -> NUM .)
    AND             reduce using rule 49 (expr -> NUM .)
    OR              reduce using rule 49 (expr -> NUM .)
    $               reduce using rule 49 (expr -> NUM .)
    )               reduce using rule 49 (expr -> NUM .)
    ]               reduce using rule 49 (expr -> NUM .)
    ,               reduce using rule 49 (expr -> NUM .)


state 41

    (50) expr -> FLOAT .

    [               reduce using rule 50 (expr -> FLOAT .)
    ;               reduce using rule 50 (expr -> FLOAT .)
    +               reduce using rule 50 (expr -> FLOAT .)
    -               reduce using rule 50 (expr -> FLOAT .)
    *               reduce using rule 50 (expr -> FLOAT .)
    /               reduce using rule 50 (expr -> FLOAT .)
    >               reduce using rule 50 (expr -> FLOAT .)
    <               reduce using rule 50 (expr -> FLOAT .)
    GTE             reduce using rule 50 (expr -> FLOAT .)
    LTE             reduce using rule 50 (expr -> FLOAT .)
    EQ              reduce using rule 50 (expr -> FLOAT .)
    NEQ             reduce using rule 50 (expr -> FLOAT .)
    %               reduce using rule 50 (expr -> FLOAT .)
    AND             reduce using rule 50 (expr -> FLOAT .)
    OR              reduce using rule 50 (expr -> FLOAT .)
    $               reduce using rule 50 (expr -> FLOAT .)
    )               reduce using rule 50 (expr -> FLOAT .)
    ]               reduce using rule 50 (expr -> FLOAT .)
    ,               reduce using rule 50 (expr -> FLOAT .)


state 42

    (4) fun -> DEF fun_name ( . funargs ) ftype { stmtlist }
    (64) funargs -> . idlist
    (65) funargs -> .
    (66) idlist -> . idlist , ID type
    (67) idlist -> . ID type

    )               reduce using rule 65 (funargs -> .)
    ID              shift and go to state 80

    funargs                        shift and go to state 78
    idlist                         shift and go to state 79

state 43

    (17) var_declare -> VAR ID [ NUM ] . type ;
    (18) var_declare -> VAR ID [ NUM ] . [ NUM ] type ;
    (53) type -> . STRINGTYPE
    (54) type -> . INTTYPE
    (55) type -> . VOIDTYPE
    (56) type -> . FLOATTYPE
    (57) type -> . type [ ]

    [               shift and go to state 81
    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15
    FLOATTYPE       shift and go to state 16

    type                           shift and go to state 82

state 44

    (46) expr -> ID .
    (51) expr -> ID . ( fcall )

    ;               reduce using rule 46 (expr -> ID .)
    +               reduce using rule 46 (expr -> ID .)
    -               reduce using rule 46 (expr -> ID .)
    *               reduce using rule 46 (expr -> ID .)
    /               reduce using rule 46 (expr -> ID .)
    >               reduce using rule 46 (expr -> ID .)
    <               reduce using rule 46 (expr -> ID .)
    GTE             reduce using rule 46 (expr -> ID .)
    LTE             reduce using rule 46 (expr -> ID .)
    EQ              reduce using rule 46 (expr -> ID .)
    NEQ             reduce using rule 46 (expr -> ID .)
    %               reduce using rule 46 (expr -> ID .)
    AND             reduce using rule 46 (expr -> ID .)
    OR              reduce using rule 46 (expr -> ID .)
    $               reduce using rule 46 (expr -> ID .)
    [               reduce using rule 46 (expr -> ID .)
    )               reduce using rule 46 (expr -> ID .)
    ]               reduce using rule 46 (expr -> ID .)
    ,               reduce using rule 46 (expr -> ID .)
    (               shift and go to state 69


state 45

    (19) var_declare -> VAR ID type = expr . ;
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    ;               shift and go to state 83
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 46

    (57) type -> type [ ] .

    =               reduce using rule 57 (type -> type [ ] .)
    ;               reduce using rule 57 (type -> type [ ] .)
    [               reduce using rule 57 (type -> type [ ] .)
    ,               reduce using rule 57 (type -> type [ ] .)
    )               reduce using rule 57 (type -> type [ ] .)
    {               reduce using rule 57 (type -> type [ ] .)


state 47

    (7) stmt -> PRINT ( . expr ) ;
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 85

state 48

    (52) expr -> ( expr . )
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    )               shift and go to state 86
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 49

    (22) stmt -> expr [ . expr ] = expr ;
    (47) expr -> expr [ . expr ]
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 87

state 50

    (25) stmt -> expr ; .

    PRINT           reduce using rule 25 (stmt -> expr ; .)
    PRINTLN         reduce using rule 25 (stmt -> expr ; .)
    WHILE           reduce using rule 25 (stmt -> expr ; .)
    IF              reduce using rule 25 (stmt -> expr ; .)
    ID              reduce using rule 25 (stmt -> expr ; .)
    RETURN          reduce using rule 25 (stmt -> expr ; .)
    INPUT           reduce using rule 25 (stmt -> expr ; .)
    STRINGTYPE      reduce using rule 25 (stmt -> expr ; .)
    INTTYPE         reduce using rule 25 (stmt -> expr ; .)
    FLOATTYPE       reduce using rule 25 (stmt -> expr ; .)
    !               reduce using rule 25 (stmt -> expr ; .)
    -               reduce using rule 25 (stmt -> expr ; .)
    STRING          reduce using rule 25 (stmt -> expr ; .)
    NUM             reduce using rule 25 (stmt -> expr ; .)
    FLOAT           reduce using rule 25 (stmt -> expr ; .)
    (               reduce using rule 25 (stmt -> expr ; .)
    $end            reduce using rule 25 (stmt -> expr ; .)
    ELSE            reduce using rule 25 (stmt -> expr ; .)
    }               reduce using rule 25 (stmt -> expr ; .)


state 51

    (30) expr -> expr + . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 88

state 52

    (31) expr -> expr - . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 89

state 53

    (32) expr -> expr * . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 90

state 54

    (33) expr -> expr / . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 91

state 55

    (34) expr -> expr > . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 92

state 56

    (35) expr -> expr < . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 93

state 57

    (36) expr -> expr GTE . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 94

state 58

    (37) expr -> expr LTE . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 95

state 59

    (38) expr -> expr EQ . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 96

state 60

    (39) expr -> expr NEQ . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 97

state 61

    (40) expr -> expr % . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 98

state 62

    (41) expr -> expr AND . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 99

state 63

    (42) expr -> expr OR . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 100

state 64

    (43) expr -> expr $ . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 101

state 65

    (8) stmt -> PRINTLN ( . ) ;
    (9) stmt -> PRINTLN ( . expr ) ;
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    )               shift and go to state 102
    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 103

state 66

    (10) stmt -> WHILE new_label . ( expr ) jz block

    (               shift and go to state 104


state 67

    (11) stmt -> IF ( . expr ) jz block
    (12) stmt -> IF ( . expr ) jz block ELSE jmp jz_label block
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 105

state 68

    (21) stmt -> ID = . expr ;
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 106

state 69

    (51) expr -> ID ( . fcall )
    (68) fcall -> . exprlist
    (69) fcall -> .
    (70) exprlist -> . exprlist , expr
    (71) exprlist -> . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    )               reduce using rule 69 (fcall -> .)
    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    fcall                          shift and go to state 107
    exprlist                       shift and go to state 108
    expr                           shift and go to state 109

state 70

    (23) stmt -> RETURN expr . ;
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    ;               shift and go to state 110
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 71

    (24) stmt -> RETURN ; .

    PRINT           reduce using rule 24 (stmt -> RETURN ; .)
    PRINTLN         reduce using rule 24 (stmt -> RETURN ; .)
    WHILE           reduce using rule 24 (stmt -> RETURN ; .)
    IF              reduce using rule 24 (stmt -> RETURN ; .)
    ID              reduce using rule 24 (stmt -> RETURN ; .)
    RETURN          reduce using rule 24 (stmt -> RETURN ; .)
    INPUT           reduce using rule 24 (stmt -> RETURN ; .)
    STRINGTYPE      reduce using rule 24 (stmt -> RETURN ; .)
    INTTYPE         reduce using rule 24 (stmt -> RETURN ; .)
    FLOATTYPE       reduce using rule 24 (stmt -> RETURN ; .)
    !               reduce using rule 24 (stmt -> RETURN ; .)
    -               reduce using rule 24 (stmt -> RETURN ; .)
    STRING          reduce using rule 24 (stmt -> RETURN ; .)
    NUM             reduce using rule 24 (stmt -> RETURN ; .)
    FLOAT           reduce using rule 24 (stmt -> RETURN ; .)
    (               reduce using rule 24 (stmt -> RETURN ; .)
    $end            reduce using rule 24 (stmt -> RETURN ; .)
    ELSE            reduce using rule 24 (stmt -> RETURN ; .)
    }               reduce using rule 24 (stmt -> RETURN ; .)


state 72

    (26) expr -> INPUT ( . )

    )               shift and go to state 111


state 73

    (27) expr -> STRINGTYPE ( . expr )
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 112

state 74

    (28) expr -> INTTYPE ( . expr )
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 113

state 75

    (29) expr -> FLOATTYPE ( . expr )
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 114

state 76

    (45) expr -> - expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 45 (expr -> - expr .)
    ;               reduce using rule 45 (expr -> - expr .)
    +               reduce using rule 45 (expr -> - expr .)
    -               reduce using rule 45 (expr -> - expr .)
    *               reduce using rule 45 (expr -> - expr .)
    /               reduce using rule 45 (expr -> - expr .)
    >               reduce using rule 45 (expr -> - expr .)
    <               reduce using rule 45 (expr -> - expr .)
    GTE             reduce using rule 45 (expr -> - expr .)
    LTE             reduce using rule 45 (expr -> - expr .)
    EQ              reduce using rule 45 (expr -> - expr .)
    NEQ             reduce using rule 45 (expr -> - expr .)
    %               reduce using rule 45 (expr -> - expr .)
    AND             reduce using rule 45 (expr -> - expr .)
    OR              reduce using rule 45 (expr -> - expr .)
    $               reduce using rule 45 (expr -> - expr .)
    )               reduce using rule 45 (expr -> - expr .)
    ]               reduce using rule 45 (expr -> - expr .)
    ,               reduce using rule 45 (expr -> - expr .)

  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! *               [ shift and go to state 53 ]
  ! /               [ shift and go to state 54 ]
  ! >               [ shift and go to state 55 ]
  ! <               [ shift and go to state 56 ]
  ! GTE             [ shift and go to state 57 ]
  ! LTE             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! %               [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! $               [ shift and go to state 64 ]
  ! [               [ shift and go to state 84 ]


state 77

    (44) expr -> ! expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 44 (expr -> ! expr .)
    ;               reduce using rule 44 (expr -> ! expr .)
    +               reduce using rule 44 (expr -> ! expr .)
    -               reduce using rule 44 (expr -> ! expr .)
    *               reduce using rule 44 (expr -> ! expr .)
    /               reduce using rule 44 (expr -> ! expr .)
    >               reduce using rule 44 (expr -> ! expr .)
    <               reduce using rule 44 (expr -> ! expr .)
    GTE             reduce using rule 44 (expr -> ! expr .)
    LTE             reduce using rule 44 (expr -> ! expr .)
    EQ              reduce using rule 44 (expr -> ! expr .)
    NEQ             reduce using rule 44 (expr -> ! expr .)
    %               reduce using rule 44 (expr -> ! expr .)
    AND             reduce using rule 44 (expr -> ! expr .)
    OR              reduce using rule 44 (expr -> ! expr .)
    $               reduce using rule 44 (expr -> ! expr .)
    )               reduce using rule 44 (expr -> ! expr .)
    ]               reduce using rule 44 (expr -> ! expr .)
    ,               reduce using rule 44 (expr -> ! expr .)

  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! *               [ shift and go to state 53 ]
  ! /               [ shift and go to state 54 ]
  ! >               [ shift and go to state 55 ]
  ! <               [ shift and go to state 56 ]
  ! GTE             [ shift and go to state 57 ]
  ! LTE             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! %               [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! $               [ shift and go to state 64 ]
  ! [               [ shift and go to state 84 ]


state 78

    (4) fun -> DEF fun_name ( funargs . ) ftype { stmtlist }

    )               shift and go to state 115


state 79

    (64) funargs -> idlist .
    (66) idlist -> idlist . , ID type

    )               reduce using rule 64 (funargs -> idlist .)
    ,               shift and go to state 116


state 80

    (67) idlist -> ID . type
    (53) type -> . STRINGTYPE
    (54) type -> . INTTYPE
    (55) type -> . VOIDTYPE
    (56) type -> . FLOATTYPE
    (57) type -> . type [ ]

    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15
    FLOATTYPE       shift and go to state 16

    type                           shift and go to state 117

state 81

    (18) var_declare -> VAR ID [ NUM ] [ . NUM ] type ;

    NUM             shift and go to state 118


state 82

    (17) var_declare -> VAR ID [ NUM ] type . ;
    (57) type -> type . [ ]

    ;               shift and go to state 119
    [               shift and go to state 23


state 83

    (19) var_declare -> VAR ID type = expr ; .

    VAR             reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    DEF             reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    PRINT           reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    PRINTLN         reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    WHILE           reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    IF              reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    ID              reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    RETURN          reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    INPUT           reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    STRINGTYPE      reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    INTTYPE         reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    FLOATTYPE       reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    !               reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    -               reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    STRING          reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    NUM             reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    FLOAT           reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    (               reduce using rule 19 (var_declare -> VAR ID type = expr ; .)
    $end            reduce using rule 19 (var_declare -> VAR ID type = expr ; .)


state 84

    (47) expr -> expr [ . expr ]
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 120

state 85

    (7) stmt -> PRINT ( expr . ) ;
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    )               shift and go to state 121
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 86

    (52) expr -> ( expr ) .

    [               reduce using rule 52 (expr -> ( expr ) .)
    ;               reduce using rule 52 (expr -> ( expr ) .)
    +               reduce using rule 52 (expr -> ( expr ) .)
    -               reduce using rule 52 (expr -> ( expr ) .)
    *               reduce using rule 52 (expr -> ( expr ) .)
    /               reduce using rule 52 (expr -> ( expr ) .)
    >               reduce using rule 52 (expr -> ( expr ) .)
    <               reduce using rule 52 (expr -> ( expr ) .)
    GTE             reduce using rule 52 (expr -> ( expr ) .)
    LTE             reduce using rule 52 (expr -> ( expr ) .)
    EQ              reduce using rule 52 (expr -> ( expr ) .)
    NEQ             reduce using rule 52 (expr -> ( expr ) .)
    %               reduce using rule 52 (expr -> ( expr ) .)
    AND             reduce using rule 52 (expr -> ( expr ) .)
    OR              reduce using rule 52 (expr -> ( expr ) .)
    $               reduce using rule 52 (expr -> ( expr ) .)
    )               reduce using rule 52 (expr -> ( expr ) .)
    ]               reduce using rule 52 (expr -> ( expr ) .)
    ,               reduce using rule 52 (expr -> ( expr ) .)


state 87

    (22) stmt -> expr [ expr . ] = expr ;
    (47) expr -> expr [ expr . ]
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    ]               shift and go to state 122
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 88

    (30) expr -> expr + expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 30 (expr -> expr + expr .)
    ;               reduce using rule 30 (expr -> expr + expr .)
    +               reduce using rule 30 (expr -> expr + expr .)
    -               reduce using rule 30 (expr -> expr + expr .)
    >               reduce using rule 30 (expr -> expr + expr .)
    <               reduce using rule 30 (expr -> expr + expr .)
    GTE             reduce using rule 30 (expr -> expr + expr .)
    LTE             reduce using rule 30 (expr -> expr + expr .)
    EQ              reduce using rule 30 (expr -> expr + expr .)
    NEQ             reduce using rule 30 (expr -> expr + expr .)
    AND             reduce using rule 30 (expr -> expr + expr .)
    OR              reduce using rule 30 (expr -> expr + expr .)
    $               reduce using rule 30 (expr -> expr + expr .)
    )               reduce using rule 30 (expr -> expr + expr .)
    ]               reduce using rule 30 (expr -> expr + expr .)
    ,               reduce using rule 30 (expr -> expr + expr .)
    *               shift and go to state 53
    /               shift and go to state 54
    %               shift and go to state 61

  ! *               [ reduce using rule 30 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 30 (expr -> expr + expr .) ]
  ! %               [ reduce using rule 30 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! >               [ shift and go to state 55 ]
  ! <               [ shift and go to state 56 ]
  ! GTE             [ shift and go to state 57 ]
  ! LTE             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! $               [ shift and go to state 64 ]
  ! [               [ shift and go to state 84 ]


state 89

    (31) expr -> expr - expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 31 (expr -> expr - expr .)
    ;               reduce using rule 31 (expr -> expr - expr .)
    +               reduce using rule 31 (expr -> expr - expr .)
    -               reduce using rule 31 (expr -> expr - expr .)
    >               reduce using rule 31 (expr -> expr - expr .)
    <               reduce using rule 31 (expr -> expr - expr .)
    GTE             reduce using rule 31 (expr -> expr - expr .)
    LTE             reduce using rule 31 (expr -> expr - expr .)
    EQ              reduce using rule 31 (expr -> expr - expr .)
    NEQ             reduce using rule 31 (expr -> expr - expr .)
    AND             reduce using rule 31 (expr -> expr - expr .)
    OR              reduce using rule 31 (expr -> expr - expr .)
    $               reduce using rule 31 (expr -> expr - expr .)
    )               reduce using rule 31 (expr -> expr - expr .)
    ]               reduce using rule 31 (expr -> expr - expr .)
    ,               reduce using rule 31 (expr -> expr - expr .)
    *               shift and go to state 53
    /               shift and go to state 54
    %               shift and go to state 61

  ! *               [ reduce using rule 31 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 31 (expr -> expr - expr .) ]
  ! %               [ reduce using rule 31 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! >               [ shift and go to state 55 ]
  ! <               [ shift and go to state 56 ]
  ! GTE             [ shift and go to state 57 ]
  ! LTE             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! $               [ shift and go to state 64 ]
  ! [               [ shift and go to state 84 ]


state 90

    (32) expr -> expr * expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 32 (expr -> expr * expr .)
    ;               reduce using rule 32 (expr -> expr * expr .)
    +               reduce using rule 32 (expr -> expr * expr .)
    -               reduce using rule 32 (expr -> expr * expr .)
    *               reduce using rule 32 (expr -> expr * expr .)
    /               reduce using rule 32 (expr -> expr * expr .)
    >               reduce using rule 32 (expr -> expr * expr .)
    <               reduce using rule 32 (expr -> expr * expr .)
    GTE             reduce using rule 32 (expr -> expr * expr .)
    LTE             reduce using rule 32 (expr -> expr * expr .)
    EQ              reduce using rule 32 (expr -> expr * expr .)
    NEQ             reduce using rule 32 (expr -> expr * expr .)
    %               reduce using rule 32 (expr -> expr * expr .)
    AND             reduce using rule 32 (expr -> expr * expr .)
    OR              reduce using rule 32 (expr -> expr * expr .)
    $               reduce using rule 32 (expr -> expr * expr .)
    )               reduce using rule 32 (expr -> expr * expr .)
    ]               reduce using rule 32 (expr -> expr * expr .)
    ,               reduce using rule 32 (expr -> expr * expr .)

  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! *               [ shift and go to state 53 ]
  ! /               [ shift and go to state 54 ]
  ! >               [ shift and go to state 55 ]
  ! <               [ shift and go to state 56 ]
  ! GTE             [ shift and go to state 57 ]
  ! LTE             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! %               [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! $               [ shift and go to state 64 ]
  ! [               [ shift and go to state 84 ]


state 91

    (33) expr -> expr / expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 33 (expr -> expr / expr .)
    ;               reduce using rule 33 (expr -> expr / expr .)
    +               reduce using rule 33 (expr -> expr / expr .)
    -               reduce using rule 33 (expr -> expr / expr .)
    *               reduce using rule 33 (expr -> expr / expr .)
    /               reduce using rule 33 (expr -> expr / expr .)
    >               reduce using rule 33 (expr -> expr / expr .)
    <               reduce using rule 33 (expr -> expr / expr .)
    GTE             reduce using rule 33 (expr -> expr / expr .)
    LTE             reduce using rule 33 (expr -> expr / expr .)
    EQ              reduce using rule 33 (expr -> expr / expr .)
    NEQ             reduce using rule 33 (expr -> expr / expr .)
    %               reduce using rule 33 (expr -> expr / expr .)
    AND             reduce using rule 33 (expr -> expr / expr .)
    OR              reduce using rule 33 (expr -> expr / expr .)
    $               reduce using rule 33 (expr -> expr / expr .)
    )               reduce using rule 33 (expr -> expr / expr .)
    ]               reduce using rule 33 (expr -> expr / expr .)
    ,               reduce using rule 33 (expr -> expr / expr .)

  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! *               [ shift and go to state 53 ]
  ! /               [ shift and go to state 54 ]
  ! >               [ shift and go to state 55 ]
  ! <               [ shift and go to state 56 ]
  ! GTE             [ shift and go to state 57 ]
  ! LTE             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! %               [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! $               [ shift and go to state 64 ]
  ! [               [ shift and go to state 84 ]


state 92

    (34) expr -> expr > expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 34 (expr -> expr > expr .)
    ;               reduce using rule 34 (expr -> expr > expr .)
    >               reduce using rule 34 (expr -> expr > expr .)
    <               reduce using rule 34 (expr -> expr > expr .)
    GTE             reduce using rule 34 (expr -> expr > expr .)
    LTE             reduce using rule 34 (expr -> expr > expr .)
    EQ              reduce using rule 34 (expr -> expr > expr .)
    NEQ             reduce using rule 34 (expr -> expr > expr .)
    AND             reduce using rule 34 (expr -> expr > expr .)
    OR              reduce using rule 34 (expr -> expr > expr .)
    )               reduce using rule 34 (expr -> expr > expr .)
    ]               reduce using rule 34 (expr -> expr > expr .)
    ,               reduce using rule 34 (expr -> expr > expr .)
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    %               shift and go to state 61
    $               shift and go to state 64

  ! +               [ reduce using rule 34 (expr -> expr > expr .) ]
  ! -               [ reduce using rule 34 (expr -> expr > expr .) ]
  ! *               [ reduce using rule 34 (expr -> expr > expr .) ]
  ! /               [ reduce using rule 34 (expr -> expr > expr .) ]
  ! %               [ reduce using rule 34 (expr -> expr > expr .) ]
  ! $               [ reduce using rule 34 (expr -> expr > expr .) ]
  ! >               [ shift and go to state 55 ]
  ! <               [ shift and go to state 56 ]
  ! GTE             [ shift and go to state 57 ]
  ! LTE             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! [               [ shift and go to state 84 ]


state 93

    (35) expr -> expr < expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 35 (expr -> expr < expr .)
    ;               reduce using rule 35 (expr -> expr < expr .)
    >               reduce using rule 35 (expr -> expr < expr .)
    <               reduce using rule 35 (expr -> expr < expr .)
    GTE             reduce using rule 35 (expr -> expr < expr .)
    LTE             reduce using rule 35 (expr -> expr < expr .)
    EQ              reduce using rule 35 (expr -> expr < expr .)
    NEQ             reduce using rule 35 (expr -> expr < expr .)
    AND             reduce using rule 35 (expr -> expr < expr .)
    OR              reduce using rule 35 (expr -> expr < expr .)
    )               reduce using rule 35 (expr -> expr < expr .)
    ]               reduce using rule 35 (expr -> expr < expr .)
    ,               reduce using rule 35 (expr -> expr < expr .)
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    %               shift and go to state 61
    $               shift and go to state 64

  ! +               [ reduce using rule 35 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 35 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 35 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 35 (expr -> expr < expr .) ]
  ! %               [ reduce using rule 35 (expr -> expr < expr .) ]
  ! $               [ reduce using rule 35 (expr -> expr < expr .) ]
  ! >               [ shift and go to state 55 ]
  ! <               [ shift and go to state 56 ]
  ! GTE             [ shift and go to state 57 ]
  ! LTE             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! [               [ shift and go to state 84 ]


state 94

    (36) expr -> expr GTE expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 36 (expr -> expr GTE expr .)
    ;               reduce using rule 36 (expr -> expr GTE expr .)
    >               reduce using rule 36 (expr -> expr GTE expr .)
    <               reduce using rule 36 (expr -> expr GTE expr .)
    GTE             reduce using rule 36 (expr -> expr GTE expr .)
    LTE             reduce using rule 36 (expr -> expr GTE expr .)
    EQ              reduce using rule 36 (expr -> expr GTE expr .)
    NEQ             reduce using rule 36 (expr -> expr GTE expr .)
    AND             reduce using rule 36 (expr -> expr GTE expr .)
    OR              reduce using rule 36 (expr -> expr GTE expr .)
    )               reduce using rule 36 (expr -> expr GTE expr .)
    ]               reduce using rule 36 (expr -> expr GTE expr .)
    ,               reduce using rule 36 (expr -> expr GTE expr .)
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    %               shift and go to state 61
    $               shift and go to state 64

  ! +               [ reduce using rule 36 (expr -> expr GTE expr .) ]
  ! -               [ reduce using rule 36 (expr -> expr GTE expr .) ]
  ! *               [ reduce using rule 36 (expr -> expr GTE expr .) ]
  ! /               [ reduce using rule 36 (expr -> expr GTE expr .) ]
  ! %               [ reduce using rule 36 (expr -> expr GTE expr .) ]
  ! $               [ reduce using rule 36 (expr -> expr GTE expr .) ]
  ! >               [ shift and go to state 55 ]
  ! <               [ shift and go to state 56 ]
  ! GTE             [ shift and go to state 57 ]
  ! LTE             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! [               [ shift and go to state 84 ]


state 95

    (37) expr -> expr LTE expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 37 (expr -> expr LTE expr .)
    ;               reduce using rule 37 (expr -> expr LTE expr .)
    >               reduce using rule 37 (expr -> expr LTE expr .)
    <               reduce using rule 37 (expr -> expr LTE expr .)
    GTE             reduce using rule 37 (expr -> expr LTE expr .)
    LTE             reduce using rule 37 (expr -> expr LTE expr .)
    EQ              reduce using rule 37 (expr -> expr LTE expr .)
    NEQ             reduce using rule 37 (expr -> expr LTE expr .)
    AND             reduce using rule 37 (expr -> expr LTE expr .)
    OR              reduce using rule 37 (expr -> expr LTE expr .)
    )               reduce using rule 37 (expr -> expr LTE expr .)
    ]               reduce using rule 37 (expr -> expr LTE expr .)
    ,               reduce using rule 37 (expr -> expr LTE expr .)
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    %               shift and go to state 61
    $               shift and go to state 64

  ! +               [ reduce using rule 37 (expr -> expr LTE expr .) ]
  ! -               [ reduce using rule 37 (expr -> expr LTE expr .) ]
  ! *               [ reduce using rule 37 (expr -> expr LTE expr .) ]
  ! /               [ reduce using rule 37 (expr -> expr LTE expr .) ]
  ! %               [ reduce using rule 37 (expr -> expr LTE expr .) ]
  ! $               [ reduce using rule 37 (expr -> expr LTE expr .) ]
  ! >               [ shift and go to state 55 ]
  ! <               [ shift and go to state 56 ]
  ! GTE             [ shift and go to state 57 ]
  ! LTE             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! [               [ shift and go to state 84 ]


state 96

    (38) expr -> expr EQ expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 38 (expr -> expr EQ expr .)
    ;               reduce using rule 38 (expr -> expr EQ expr .)
    EQ              reduce using rule 38 (expr -> expr EQ expr .)
    NEQ             reduce using rule 38 (expr -> expr EQ expr .)
    AND             reduce using rule 38 (expr -> expr EQ expr .)
    OR              reduce using rule 38 (expr -> expr EQ expr .)
    )               reduce using rule 38 (expr -> expr EQ expr .)
    ]               reduce using rule 38 (expr -> expr EQ expr .)
    ,               reduce using rule 38 (expr -> expr EQ expr .)
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    %               shift and go to state 61
    $               shift and go to state 64

  ! +               [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! -               [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! *               [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! /               [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! >               [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! <               [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! GTE             [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! LTE             [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! %               [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! $               [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! [               [ shift and go to state 84 ]


state 97

    (39) expr -> expr NEQ expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 39 (expr -> expr NEQ expr .)
    ;               reduce using rule 39 (expr -> expr NEQ expr .)
    EQ              reduce using rule 39 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 39 (expr -> expr NEQ expr .)
    AND             reduce using rule 39 (expr -> expr NEQ expr .)
    OR              reduce using rule 39 (expr -> expr NEQ expr .)
    )               reduce using rule 39 (expr -> expr NEQ expr .)
    ]               reduce using rule 39 (expr -> expr NEQ expr .)
    ,               reduce using rule 39 (expr -> expr NEQ expr .)
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    %               shift and go to state 61
    $               shift and go to state 64

  ! +               [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! -               [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! *               [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! /               [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! >               [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! <               [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! GTE             [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! LTE             [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! %               [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! $               [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! [               [ shift and go to state 84 ]


state 98

    (40) expr -> expr % expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 40 (expr -> expr % expr .)
    ;               reduce using rule 40 (expr -> expr % expr .)
    +               reduce using rule 40 (expr -> expr % expr .)
    -               reduce using rule 40 (expr -> expr % expr .)
    *               reduce using rule 40 (expr -> expr % expr .)
    /               reduce using rule 40 (expr -> expr % expr .)
    >               reduce using rule 40 (expr -> expr % expr .)
    <               reduce using rule 40 (expr -> expr % expr .)
    GTE             reduce using rule 40 (expr -> expr % expr .)
    LTE             reduce using rule 40 (expr -> expr % expr .)
    EQ              reduce using rule 40 (expr -> expr % expr .)
    NEQ             reduce using rule 40 (expr -> expr % expr .)
    %               reduce using rule 40 (expr -> expr % expr .)
    AND             reduce using rule 40 (expr -> expr % expr .)
    OR              reduce using rule 40 (expr -> expr % expr .)
    $               reduce using rule 40 (expr -> expr % expr .)
    )               reduce using rule 40 (expr -> expr % expr .)
    ]               reduce using rule 40 (expr -> expr % expr .)
    ,               reduce using rule 40 (expr -> expr % expr .)

  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! *               [ shift and go to state 53 ]
  ! /               [ shift and go to state 54 ]
  ! >               [ shift and go to state 55 ]
  ! <               [ shift and go to state 56 ]
  ! GTE             [ shift and go to state 57 ]
  ! LTE             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! %               [ shift and go to state 61 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! $               [ shift and go to state 64 ]
  ! [               [ shift and go to state 84 ]


state 99

    (41) expr -> expr AND expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 41 (expr -> expr AND expr .)
    ;               reduce using rule 41 (expr -> expr AND expr .)
    EQ              reduce using rule 41 (expr -> expr AND expr .)
    NEQ             reduce using rule 41 (expr -> expr AND expr .)
    AND             reduce using rule 41 (expr -> expr AND expr .)
    OR              reduce using rule 41 (expr -> expr AND expr .)
    )               reduce using rule 41 (expr -> expr AND expr .)
    ]               reduce using rule 41 (expr -> expr AND expr .)
    ,               reduce using rule 41 (expr -> expr AND expr .)
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    %               shift and go to state 61
    $               shift and go to state 64

  ! +               [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! -               [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! *               [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! /               [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! >               [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! <               [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! GTE             [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! LTE             [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! %               [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! $               [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! [               [ shift and go to state 84 ]


state 100

    (42) expr -> expr OR expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 42 (expr -> expr OR expr .)
    ;               reduce using rule 42 (expr -> expr OR expr .)
    EQ              reduce using rule 42 (expr -> expr OR expr .)
    NEQ             reduce using rule 42 (expr -> expr OR expr .)
    AND             reduce using rule 42 (expr -> expr OR expr .)
    OR              reduce using rule 42 (expr -> expr OR expr .)
    )               reduce using rule 42 (expr -> expr OR expr .)
    ]               reduce using rule 42 (expr -> expr OR expr .)
    ,               reduce using rule 42 (expr -> expr OR expr .)
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    %               shift and go to state 61
    $               shift and go to state 64

  ! +               [ reduce using rule 42 (expr -> expr OR expr .) ]
  ! -               [ reduce using rule 42 (expr -> expr OR expr .) ]
  ! *               [ reduce using rule 42 (expr -> expr OR expr .) ]
  ! /               [ reduce using rule 42 (expr -> expr OR expr .) ]
  ! >               [ reduce using rule 42 (expr -> expr OR expr .) ]
  ! <               [ reduce using rule 42 (expr -> expr OR expr .) ]
  ! GTE             [ reduce using rule 42 (expr -> expr OR expr .) ]
  ! LTE             [ reduce using rule 42 (expr -> expr OR expr .) ]
  ! %               [ reduce using rule 42 (expr -> expr OR expr .) ]
  ! $               [ reduce using rule 42 (expr -> expr OR expr .) ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! [               [ shift and go to state 84 ]


state 101

    (43) expr -> expr $ expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    [               reduce using rule 43 (expr -> expr $ expr .)
    ;               reduce using rule 43 (expr -> expr $ expr .)
    +               reduce using rule 43 (expr -> expr $ expr .)
    -               reduce using rule 43 (expr -> expr $ expr .)
    >               reduce using rule 43 (expr -> expr $ expr .)
    <               reduce using rule 43 (expr -> expr $ expr .)
    GTE             reduce using rule 43 (expr -> expr $ expr .)
    LTE             reduce using rule 43 (expr -> expr $ expr .)
    EQ              reduce using rule 43 (expr -> expr $ expr .)
    NEQ             reduce using rule 43 (expr -> expr $ expr .)
    AND             reduce using rule 43 (expr -> expr $ expr .)
    OR              reduce using rule 43 (expr -> expr $ expr .)
    $               reduce using rule 43 (expr -> expr $ expr .)
    )               reduce using rule 43 (expr -> expr $ expr .)
    ]               reduce using rule 43 (expr -> expr $ expr .)
    ,               reduce using rule 43 (expr -> expr $ expr .)
    *               shift and go to state 53
    /               shift and go to state 54
    %               shift and go to state 61

  ! *               [ reduce using rule 43 (expr -> expr $ expr .) ]
  ! /               [ reduce using rule 43 (expr -> expr $ expr .) ]
  ! %               [ reduce using rule 43 (expr -> expr $ expr .) ]
  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! >               [ shift and go to state 55 ]
  ! <               [ shift and go to state 56 ]
  ! GTE             [ shift and go to state 57 ]
  ! LTE             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! AND             [ shift and go to state 62 ]
  ! OR              [ shift and go to state 63 ]
  ! $               [ shift and go to state 64 ]
  ! [               [ shift and go to state 84 ]


state 102

    (8) stmt -> PRINTLN ( ) . ;

    ;               shift and go to state 123


state 103

    (9) stmt -> PRINTLN ( expr . ) ;
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    )               shift and go to state 124
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 104

    (10) stmt -> WHILE new_label ( . expr ) jz block
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 125

state 105

    (11) stmt -> IF ( expr . ) jz block
    (12) stmt -> IF ( expr . ) jz block ELSE jmp jz_label block
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    )               shift and go to state 126
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 106

    (21) stmt -> ID = expr . ;
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    ;               shift and go to state 127
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 107

    (51) expr -> ID ( fcall . )

    )               shift and go to state 128


state 108

    (68) fcall -> exprlist .
    (70) exprlist -> exprlist . , expr

    )               reduce using rule 68 (fcall -> exprlist .)
    ,               shift and go to state 129


state 109

    (71) exprlist -> expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    ,               reduce using rule 71 (exprlist -> expr .)
    )               reduce using rule 71 (exprlist -> expr .)
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 110

    (23) stmt -> RETURN expr ; .

    PRINT           reduce using rule 23 (stmt -> RETURN expr ; .)
    PRINTLN         reduce using rule 23 (stmt -> RETURN expr ; .)
    WHILE           reduce using rule 23 (stmt -> RETURN expr ; .)
    IF              reduce using rule 23 (stmt -> RETURN expr ; .)
    ID              reduce using rule 23 (stmt -> RETURN expr ; .)
    RETURN          reduce using rule 23 (stmt -> RETURN expr ; .)
    INPUT           reduce using rule 23 (stmt -> RETURN expr ; .)
    STRINGTYPE      reduce using rule 23 (stmt -> RETURN expr ; .)
    INTTYPE         reduce using rule 23 (stmt -> RETURN expr ; .)
    FLOATTYPE       reduce using rule 23 (stmt -> RETURN expr ; .)
    !               reduce using rule 23 (stmt -> RETURN expr ; .)
    -               reduce using rule 23 (stmt -> RETURN expr ; .)
    STRING          reduce using rule 23 (stmt -> RETURN expr ; .)
    NUM             reduce using rule 23 (stmt -> RETURN expr ; .)
    FLOAT           reduce using rule 23 (stmt -> RETURN expr ; .)
    (               reduce using rule 23 (stmt -> RETURN expr ; .)
    $end            reduce using rule 23 (stmt -> RETURN expr ; .)
    ELSE            reduce using rule 23 (stmt -> RETURN expr ; .)
    }               reduce using rule 23 (stmt -> RETURN expr ; .)


state 111

    (26) expr -> INPUT ( ) .

    [               reduce using rule 26 (expr -> INPUT ( ) .)
    ;               reduce using rule 26 (expr -> INPUT ( ) .)
    +               reduce using rule 26 (expr -> INPUT ( ) .)
    -               reduce using rule 26 (expr -> INPUT ( ) .)
    *               reduce using rule 26 (expr -> INPUT ( ) .)
    /               reduce using rule 26 (expr -> INPUT ( ) .)
    >               reduce using rule 26 (expr -> INPUT ( ) .)
    <               reduce using rule 26 (expr -> INPUT ( ) .)
    GTE             reduce using rule 26 (expr -> INPUT ( ) .)
    LTE             reduce using rule 26 (expr -> INPUT ( ) .)
    EQ              reduce using rule 26 (expr -> INPUT ( ) .)
    NEQ             reduce using rule 26 (expr -> INPUT ( ) .)
    %               reduce using rule 26 (expr -> INPUT ( ) .)
    AND             reduce using rule 26 (expr -> INPUT ( ) .)
    OR              reduce using rule 26 (expr -> INPUT ( ) .)
    $               reduce using rule 26 (expr -> INPUT ( ) .)
    )               reduce using rule 26 (expr -> INPUT ( ) .)
    ]               reduce using rule 26 (expr -> INPUT ( ) .)
    ,               reduce using rule 26 (expr -> INPUT ( ) .)


state 112

    (27) expr -> STRINGTYPE ( expr . )
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    )               shift and go to state 130
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 113

    (28) expr -> INTTYPE ( expr . )
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    )               shift and go to state 131
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 114

    (29) expr -> FLOATTYPE ( expr . )
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    )               shift and go to state 132
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 115

    (4) fun -> DEF fun_name ( funargs ) . ftype { stmtlist }
    (6) ftype -> . type
    (53) type -> . STRINGTYPE
    (54) type -> . INTTYPE
    (55) type -> . VOIDTYPE
    (56) type -> . FLOATTYPE
    (57) type -> . type [ ]

    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15
    FLOATTYPE       shift and go to state 16

    ftype                          shift and go to state 133
    type                           shift and go to state 134

state 116

    (66) idlist -> idlist , . ID type

    ID              shift and go to state 135


state 117

    (67) idlist -> ID type .
    (57) type -> type . [ ]

    ,               reduce using rule 67 (idlist -> ID type .)
    )               reduce using rule 67 (idlist -> ID type .)
    [               shift and go to state 23


state 118

    (18) var_declare -> VAR ID [ NUM ] [ NUM . ] type ;

    ]               shift and go to state 136


state 119

    (17) var_declare -> VAR ID [ NUM ] type ; .

    VAR             reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    DEF             reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    PRINT           reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    PRINTLN         reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    WHILE           reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    IF              reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    ID              reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    RETURN          reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    INPUT           reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    STRINGTYPE      reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    INTTYPE         reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    FLOATTYPE       reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    !               reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    -               reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    STRING          reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    NUM             reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    FLOAT           reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    (               reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)
    $end            reduce using rule 17 (var_declare -> VAR ID [ NUM ] type ; .)


state 120

    (47) expr -> expr [ expr . ]
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    ]               shift and go to state 137
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 121

    (7) stmt -> PRINT ( expr ) . ;

    ;               shift and go to state 138


state 122

    (22) stmt -> expr [ expr ] . = expr ;
    (47) expr -> expr [ expr ] .

    =               shift and go to state 139
    [               reduce using rule 47 (expr -> expr [ expr ] .)
    ;               reduce using rule 47 (expr -> expr [ expr ] .)
    +               reduce using rule 47 (expr -> expr [ expr ] .)
    -               reduce using rule 47 (expr -> expr [ expr ] .)
    *               reduce using rule 47 (expr -> expr [ expr ] .)
    /               reduce using rule 47 (expr -> expr [ expr ] .)
    >               reduce using rule 47 (expr -> expr [ expr ] .)
    <               reduce using rule 47 (expr -> expr [ expr ] .)
    GTE             reduce using rule 47 (expr -> expr [ expr ] .)
    LTE             reduce using rule 47 (expr -> expr [ expr ] .)
    EQ              reduce using rule 47 (expr -> expr [ expr ] .)
    NEQ             reduce using rule 47 (expr -> expr [ expr ] .)
    %               reduce using rule 47 (expr -> expr [ expr ] .)
    AND             reduce using rule 47 (expr -> expr [ expr ] .)
    OR              reduce using rule 47 (expr -> expr [ expr ] .)
    $               reduce using rule 47 (expr -> expr [ expr ] .)


state 123

    (8) stmt -> PRINTLN ( ) ; .

    PRINT           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    PRINTLN         reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    WHILE           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    IF              reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ID              reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    RETURN          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    INPUT           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    STRINGTYPE      reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    INTTYPE         reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    FLOATTYPE       reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    !               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    -               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    STRING          reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    NUM             reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    FLOAT           reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    (               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    $end            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    ELSE            reduce using rule 8 (stmt -> PRINTLN ( ) ; .)
    }               reduce using rule 8 (stmt -> PRINTLN ( ) ; .)


state 124

    (9) stmt -> PRINTLN ( expr ) . ;

    ;               shift and go to state 140


state 125

    (10) stmt -> WHILE new_label ( expr . ) jz block
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    )               shift and go to state 141
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 126

    (11) stmt -> IF ( expr ) . jz block
    (12) stmt -> IF ( expr ) . jz block ELSE jmp jz_label block
    (14) jz -> .

    {               reduce using rule 14 (jz -> .)
    PRINT           reduce using rule 14 (jz -> .)
    PRINTLN         reduce using rule 14 (jz -> .)
    WHILE           reduce using rule 14 (jz -> .)
    IF              reduce using rule 14 (jz -> .)
    ID              reduce using rule 14 (jz -> .)
    RETURN          reduce using rule 14 (jz -> .)
    INPUT           reduce using rule 14 (jz -> .)
    STRINGTYPE      reduce using rule 14 (jz -> .)
    INTTYPE         reduce using rule 14 (jz -> .)
    FLOATTYPE       reduce using rule 14 (jz -> .)
    !               reduce using rule 14 (jz -> .)
    -               reduce using rule 14 (jz -> .)
    STRING          reduce using rule 14 (jz -> .)
    NUM             reduce using rule 14 (jz -> .)
    FLOAT           reduce using rule 14 (jz -> .)
    (               reduce using rule 14 (jz -> .)

    jz                             shift and go to state 142

state 127

    (21) stmt -> ID = expr ; .

    PRINT           reduce using rule 21 (stmt -> ID = expr ; .)
    PRINTLN         reduce using rule 21 (stmt -> ID = expr ; .)
    WHILE           reduce using rule 21 (stmt -> ID = expr ; .)
    IF              reduce using rule 21 (stmt -> ID = expr ; .)
    ID              reduce using rule 21 (stmt -> ID = expr ; .)
    RETURN          reduce using rule 21 (stmt -> ID = expr ; .)
    INPUT           reduce using rule 21 (stmt -> ID = expr ; .)
    STRINGTYPE      reduce using rule 21 (stmt -> ID = expr ; .)
    INTTYPE         reduce using rule 21 (stmt -> ID = expr ; .)
    FLOATTYPE       reduce using rule 21 (stmt -> ID = expr ; .)
    !               reduce using rule 21 (stmt -> ID = expr ; .)
    -               reduce using rule 21 (stmt -> ID = expr ; .)
    STRING          reduce using rule 21 (stmt -> ID = expr ; .)
    NUM             reduce using rule 21 (stmt -> ID = expr ; .)
    FLOAT           reduce using rule 21 (stmt -> ID = expr ; .)
    (               reduce using rule 21 (stmt -> ID = expr ; .)
    $end            reduce using rule 21 (stmt -> ID = expr ; .)
    ELSE            reduce using rule 21 (stmt -> ID = expr ; .)
    }               reduce using rule 21 (stmt -> ID = expr ; .)


state 128

    (51) expr -> ID ( fcall ) .

    [               reduce using rule 51 (expr -> ID ( fcall ) .)
    ;               reduce using rule 51 (expr -> ID ( fcall ) .)
    +               reduce using rule 51 (expr -> ID ( fcall ) .)
    -               reduce using rule 51 (expr -> ID ( fcall ) .)
    *               reduce using rule 51 (expr -> ID ( fcall ) .)
    /               reduce using rule 51 (expr -> ID ( fcall ) .)
    >               reduce using rule 51 (expr -> ID ( fcall ) .)
    <               reduce using rule 51 (expr -> ID ( fcall ) .)
    GTE             reduce using rule 51 (expr -> ID ( fcall ) .)
    LTE             reduce using rule 51 (expr -> ID ( fcall ) .)
    EQ              reduce using rule 51 (expr -> ID ( fcall ) .)
    NEQ             reduce using rule 51 (expr -> ID ( fcall ) .)
    %               reduce using rule 51 (expr -> ID ( fcall ) .)
    AND             reduce using rule 51 (expr -> ID ( fcall ) .)
    OR              reduce using rule 51 (expr -> ID ( fcall ) .)
    $               reduce using rule 51 (expr -> ID ( fcall ) .)
    )               reduce using rule 51 (expr -> ID ( fcall ) .)
    ]               reduce using rule 51 (expr -> ID ( fcall ) .)
    ,               reduce using rule 51 (expr -> ID ( fcall ) .)


state 129

    (70) exprlist -> exprlist , . expr
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 143

state 130

    (27) expr -> STRINGTYPE ( expr ) .

    [               reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    ;               reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    +               reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    -               reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    *               reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    /               reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    >               reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    <               reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    GTE             reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    LTE             reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    EQ              reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    NEQ             reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    %               reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    AND             reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    OR              reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    $               reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    )               reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    ]               reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)
    ,               reduce using rule 27 (expr -> STRINGTYPE ( expr ) .)


state 131

    (28) expr -> INTTYPE ( expr ) .

    [               reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    ;               reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    +               reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    -               reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    *               reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    /               reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    >               reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    <               reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    GTE             reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    LTE             reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    EQ              reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    NEQ             reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    %               reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    AND             reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    OR              reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    $               reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    )               reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    ]               reduce using rule 28 (expr -> INTTYPE ( expr ) .)
    ,               reduce using rule 28 (expr -> INTTYPE ( expr ) .)


state 132

    (29) expr -> FLOATTYPE ( expr ) .

    [               reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    ;               reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    +               reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    -               reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    *               reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    /               reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    >               reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    <               reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    GTE             reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    LTE             reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    EQ              reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    NEQ             reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    %               reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    AND             reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    OR              reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    $               reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    )               reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    ]               reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)
    ,               reduce using rule 29 (expr -> FLOATTYPE ( expr ) .)


state 133

    (4) fun -> DEF fun_name ( funargs ) ftype . { stmtlist }

    {               shift and go to state 144


state 134

    (6) ftype -> type .
    (57) type -> type . [ ]

    {               reduce using rule 6 (ftype -> type .)
    [               shift and go to state 23


state 135

    (66) idlist -> idlist , ID . type
    (53) type -> . STRINGTYPE
    (54) type -> . INTTYPE
    (55) type -> . VOIDTYPE
    (56) type -> . FLOATTYPE
    (57) type -> . type [ ]

    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15
    FLOATTYPE       shift and go to state 16

    type                           shift and go to state 145

state 136

    (18) var_declare -> VAR ID [ NUM ] [ NUM ] . type ;
    (53) type -> . STRINGTYPE
    (54) type -> . INTTYPE
    (55) type -> . VOIDTYPE
    (56) type -> . FLOATTYPE
    (57) type -> . type [ ]

    STRINGTYPE      shift and go to state 13
    INTTYPE         shift and go to state 14
    VOIDTYPE        shift and go to state 15
    FLOATTYPE       shift and go to state 16

    type                           shift and go to state 146

state 137

    (47) expr -> expr [ expr ] .

    ;               reduce using rule 47 (expr -> expr [ expr ] .)
    +               reduce using rule 47 (expr -> expr [ expr ] .)
    -               reduce using rule 47 (expr -> expr [ expr ] .)
    *               reduce using rule 47 (expr -> expr [ expr ] .)
    /               reduce using rule 47 (expr -> expr [ expr ] .)
    >               reduce using rule 47 (expr -> expr [ expr ] .)
    <               reduce using rule 47 (expr -> expr [ expr ] .)
    GTE             reduce using rule 47 (expr -> expr [ expr ] .)
    LTE             reduce using rule 47 (expr -> expr [ expr ] .)
    EQ              reduce using rule 47 (expr -> expr [ expr ] .)
    NEQ             reduce using rule 47 (expr -> expr [ expr ] .)
    %               reduce using rule 47 (expr -> expr [ expr ] .)
    AND             reduce using rule 47 (expr -> expr [ expr ] .)
    OR              reduce using rule 47 (expr -> expr [ expr ] .)
    $               reduce using rule 47 (expr -> expr [ expr ] .)
    [               reduce using rule 47 (expr -> expr [ expr ] .)
    )               reduce using rule 47 (expr -> expr [ expr ] .)
    ]               reduce using rule 47 (expr -> expr [ expr ] .)
    ,               reduce using rule 47 (expr -> expr [ expr ] .)


state 138

    (7) stmt -> PRINT ( expr ) ; .

    PRINT           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    PRINTLN         reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    WHILE           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    IF              reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ID              reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    RETURN          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    INPUT           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    STRINGTYPE      reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    INTTYPE         reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    FLOATTYPE       reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    !               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    -               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    STRING          reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    NUM             reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    FLOAT           reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    (               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    $end            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    ELSE            reduce using rule 7 (stmt -> PRINT ( expr ) ; .)
    }               reduce using rule 7 (stmt -> PRINT ( expr ) ; .)


state 139

    (22) stmt -> expr [ expr ] = . expr ;
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    ID              shift and go to state 44
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 147

state 140

    (9) stmt -> PRINTLN ( expr ) ; .

    PRINT           reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    PRINTLN         reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    WHILE           reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    IF              reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    ID              reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    RETURN          reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    INPUT           reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    STRINGTYPE      reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    INTTYPE         reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    FLOATTYPE       reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    !               reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    -               reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    STRING          reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    NUM             reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    FLOAT           reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    (               reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    $end            reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    ELSE            reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)
    }               reduce using rule 9 (stmt -> PRINTLN ( expr ) ; .)


state 141

    (10) stmt -> WHILE new_label ( expr ) . jz block
    (14) jz -> .

    {               reduce using rule 14 (jz -> .)
    PRINT           reduce using rule 14 (jz -> .)
    PRINTLN         reduce using rule 14 (jz -> .)
    WHILE           reduce using rule 14 (jz -> .)
    IF              reduce using rule 14 (jz -> .)
    ID              reduce using rule 14 (jz -> .)
    RETURN          reduce using rule 14 (jz -> .)
    INPUT           reduce using rule 14 (jz -> .)
    STRINGTYPE      reduce using rule 14 (jz -> .)
    INTTYPE         reduce using rule 14 (jz -> .)
    FLOATTYPE       reduce using rule 14 (jz -> .)
    !               reduce using rule 14 (jz -> .)
    -               reduce using rule 14 (jz -> .)
    STRING          reduce using rule 14 (jz -> .)
    NUM             reduce using rule 14 (jz -> .)
    FLOAT           reduce using rule 14 (jz -> .)
    (               reduce using rule 14 (jz -> .)

    jz                             shift and go to state 148

state 142

    (11) stmt -> IF ( expr ) jz . block
    (12) stmt -> IF ( expr ) jz . block ELSE jmp jz_label block
    (72) block -> . { stmtlist }
    (73) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . PRINTLN ( expr ) ;
    (10) stmt -> . WHILE new_label ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block
    (12) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (21) stmt -> . ID = expr ;
    (22) stmt -> . expr [ expr ] = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . expr ;
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    {               shift and go to state 150
    PRINT           shift and go to state 25
    PRINTLN         shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30
    ID              shift and go to state 31
    RETURN          shift and go to state 32
    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 27
    block                          shift and go to state 149
    stmt                           shift and go to state 151

state 143

    (70) exprlist -> exprlist , expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    ,               reduce using rule 70 (exprlist -> exprlist , expr .)
    )               reduce using rule 70 (exprlist -> exprlist , expr .)
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 144

    (4) fun -> DEF fun_name ( funargs ) ftype { . stmtlist }
    (62) stmtlist -> . stmtlist stmt
    (63) stmtlist -> .

    }               reduce using rule 63 (stmtlist -> .)
    PRINT           reduce using rule 63 (stmtlist -> .)
    PRINTLN         reduce using rule 63 (stmtlist -> .)
    WHILE           reduce using rule 63 (stmtlist -> .)
    IF              reduce using rule 63 (stmtlist -> .)
    ID              reduce using rule 63 (stmtlist -> .)
    RETURN          reduce using rule 63 (stmtlist -> .)
    INPUT           reduce using rule 63 (stmtlist -> .)
    STRINGTYPE      reduce using rule 63 (stmtlist -> .)
    INTTYPE         reduce using rule 63 (stmtlist -> .)
    FLOATTYPE       reduce using rule 63 (stmtlist -> .)
    !               reduce using rule 63 (stmtlist -> .)
    -               reduce using rule 63 (stmtlist -> .)
    STRING          reduce using rule 63 (stmtlist -> .)
    NUM             reduce using rule 63 (stmtlist -> .)
    FLOAT           reduce using rule 63 (stmtlist -> .)
    (               reduce using rule 63 (stmtlist -> .)

    stmtlist                       shift and go to state 152

state 145

    (66) idlist -> idlist , ID type .
    (57) type -> type . [ ]

    ,               reduce using rule 66 (idlist -> idlist , ID type .)
    )               reduce using rule 66 (idlist -> idlist , ID type .)
    [               shift and go to state 23


state 146

    (18) var_declare -> VAR ID [ NUM ] [ NUM ] type . ;
    (57) type -> type . [ ]

    ;               shift and go to state 153
    [               shift and go to state 23


state 147

    (22) stmt -> expr [ expr ] = expr . ;
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . GTE expr
    (37) expr -> expr . LTE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . % expr
    (41) expr -> expr . AND expr
    (42) expr -> expr . OR expr
    (43) expr -> expr . $ expr
    (47) expr -> expr . [ expr ]

    ;               shift and go to state 154
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    >               shift and go to state 55
    <               shift and go to state 56
    GTE             shift and go to state 57
    LTE             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    %               shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    $               shift and go to state 64
    [               shift and go to state 84


state 148

    (10) stmt -> WHILE new_label ( expr ) jz . block
    (72) block -> . { stmtlist }
    (73) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . PRINTLN ( expr ) ;
    (10) stmt -> . WHILE new_label ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block
    (12) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (21) stmt -> . ID = expr ;
    (22) stmt -> . expr [ expr ] = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . expr ;
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    {               shift and go to state 150
    PRINT           shift and go to state 25
    PRINTLN         shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30
    ID              shift and go to state 31
    RETURN          shift and go to state 32
    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 27
    block                          shift and go to state 155
    stmt                           shift and go to state 151

state 149

    (11) stmt -> IF ( expr ) jz block .
    (12) stmt -> IF ( expr ) jz block . ELSE jmp jz_label block

  ! shift/reduce conflict for ELSE resolved as shift
    PRINT           reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    PRINTLN         reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    WHILE           reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    IF              reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    ID              reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    RETURN          reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    INPUT           reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    STRINGTYPE      reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    INTTYPE         reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    FLOATTYPE       reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    !               reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    -               reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    STRING          reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    NUM             reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    FLOAT           reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    (               reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    $end            reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    }               reduce using rule 11 (stmt -> IF ( expr ) jz block .)
    ELSE            shift and go to state 156

  ! ELSE            [ reduce using rule 11 (stmt -> IF ( expr ) jz block .) ]


state 150

    (72) block -> { . stmtlist }
    (62) stmtlist -> . stmtlist stmt
    (63) stmtlist -> .

    }               reduce using rule 63 (stmtlist -> .)
    PRINT           reduce using rule 63 (stmtlist -> .)
    PRINTLN         reduce using rule 63 (stmtlist -> .)
    WHILE           reduce using rule 63 (stmtlist -> .)
    IF              reduce using rule 63 (stmtlist -> .)
    ID              reduce using rule 63 (stmtlist -> .)
    RETURN          reduce using rule 63 (stmtlist -> .)
    INPUT           reduce using rule 63 (stmtlist -> .)
    STRINGTYPE      reduce using rule 63 (stmtlist -> .)
    INTTYPE         reduce using rule 63 (stmtlist -> .)
    FLOATTYPE       reduce using rule 63 (stmtlist -> .)
    !               reduce using rule 63 (stmtlist -> .)
    -               reduce using rule 63 (stmtlist -> .)
    STRING          reduce using rule 63 (stmtlist -> .)
    NUM             reduce using rule 63 (stmtlist -> .)
    FLOAT           reduce using rule 63 (stmtlist -> .)
    (               reduce using rule 63 (stmtlist -> .)

    stmtlist                       shift and go to state 157

state 151

    (73) block -> stmt .

    ELSE            reduce using rule 73 (block -> stmt .)
    PRINT           reduce using rule 73 (block -> stmt .)
    PRINTLN         reduce using rule 73 (block -> stmt .)
    WHILE           reduce using rule 73 (block -> stmt .)
    IF              reduce using rule 73 (block -> stmt .)
    ID              reduce using rule 73 (block -> stmt .)
    RETURN          reduce using rule 73 (block -> stmt .)
    INPUT           reduce using rule 73 (block -> stmt .)
    STRINGTYPE      reduce using rule 73 (block -> stmt .)
    INTTYPE         reduce using rule 73 (block -> stmt .)
    FLOATTYPE       reduce using rule 73 (block -> stmt .)
    !               reduce using rule 73 (block -> stmt .)
    -               reduce using rule 73 (block -> stmt .)
    STRING          reduce using rule 73 (block -> stmt .)
    NUM             reduce using rule 73 (block -> stmt .)
    FLOAT           reduce using rule 73 (block -> stmt .)
    (               reduce using rule 73 (block -> stmt .)
    $end            reduce using rule 73 (block -> stmt .)
    }               reduce using rule 73 (block -> stmt .)


state 152

    (4) fun -> DEF fun_name ( funargs ) ftype { stmtlist . }
    (62) stmtlist -> stmtlist . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . PRINTLN ( expr ) ;
    (10) stmt -> . WHILE new_label ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block
    (12) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (21) stmt -> . ID = expr ;
    (22) stmt -> . expr [ expr ] = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . expr ;
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    }               shift and go to state 158
    PRINT           shift and go to state 25
    PRINTLN         shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30
    ID              shift and go to state 31
    RETURN          shift and go to state 32
    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    stmt                           shift and go to state 24
    expr                           shift and go to state 27

state 153

    (18) var_declare -> VAR ID [ NUM ] [ NUM ] type ; .

    VAR             reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    DEF             reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    PRINT           reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    PRINTLN         reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    WHILE           reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    IF              reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    ID              reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    RETURN          reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    INPUT           reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    STRINGTYPE      reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    INTTYPE         reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    FLOATTYPE       reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    !               reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    -               reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    STRING          reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    NUM             reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    FLOAT           reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    (               reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)
    $end            reduce using rule 18 (var_declare -> VAR ID [ NUM ] [ NUM ] type ; .)


state 154

    (22) stmt -> expr [ expr ] = expr ; .

    PRINT           reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    PRINTLN         reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    WHILE           reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    IF              reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    ID              reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    RETURN          reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    INPUT           reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    STRINGTYPE      reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    INTTYPE         reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    FLOATTYPE       reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    !               reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    -               reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    STRING          reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    NUM             reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    FLOAT           reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    (               reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    $end            reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    ELSE            reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)
    }               reduce using rule 22 (stmt -> expr [ expr ] = expr ; .)


state 155

    (10) stmt -> WHILE new_label ( expr ) jz block .

    PRINT           reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    PRINTLN         reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    WHILE           reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    IF              reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    ID              reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    RETURN          reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    INPUT           reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    STRINGTYPE      reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    INTTYPE         reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    FLOATTYPE       reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    !               reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    -               reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    STRING          reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    NUM             reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    FLOAT           reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    (               reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    $end            reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    ELSE            reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)
    }               reduce using rule 10 (stmt -> WHILE new_label ( expr ) jz block .)


state 156

    (12) stmt -> IF ( expr ) jz block ELSE . jmp jz_label block
    (13) jmp -> .

    {               reduce using rule 13 (jmp -> .)
    PRINT           reduce using rule 13 (jmp -> .)
    PRINTLN         reduce using rule 13 (jmp -> .)
    WHILE           reduce using rule 13 (jmp -> .)
    IF              reduce using rule 13 (jmp -> .)
    ID              reduce using rule 13 (jmp -> .)
    RETURN          reduce using rule 13 (jmp -> .)
    INPUT           reduce using rule 13 (jmp -> .)
    STRINGTYPE      reduce using rule 13 (jmp -> .)
    INTTYPE         reduce using rule 13 (jmp -> .)
    FLOATTYPE       reduce using rule 13 (jmp -> .)
    !               reduce using rule 13 (jmp -> .)
    -               reduce using rule 13 (jmp -> .)
    STRING          reduce using rule 13 (jmp -> .)
    NUM             reduce using rule 13 (jmp -> .)
    FLOAT           reduce using rule 13 (jmp -> .)
    (               reduce using rule 13 (jmp -> .)

    jmp                            shift and go to state 159

state 157

    (72) block -> { stmtlist . }
    (62) stmtlist -> stmtlist . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . PRINTLN ( expr ) ;
    (10) stmt -> . WHILE new_label ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block
    (12) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (21) stmt -> . ID = expr ;
    (22) stmt -> . expr [ expr ] = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . expr ;
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    }               shift and go to state 160
    PRINT           shift and go to state 25
    PRINTLN         shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30
    ID              shift and go to state 31
    RETURN          shift and go to state 32
    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    stmt                           shift and go to state 24
    expr                           shift and go to state 27

state 158

    (4) fun -> DEF fun_name ( funargs ) ftype { stmtlist } .

    DEF             reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    PRINT           reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    PRINTLN         reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    WHILE           reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    IF              reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    ID              reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    RETURN          reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    INPUT           reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    STRINGTYPE      reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    INTTYPE         reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    FLOATTYPE       reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    !               reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    -               reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    STRING          reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    NUM             reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    FLOAT           reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    (               reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)
    $end            reduce using rule 4 (fun -> DEF fun_name ( funargs ) ftype { stmtlist } .)


state 159

    (12) stmt -> IF ( expr ) jz block ELSE jmp . jz_label block
    (15) jz_label -> .

    {               reduce using rule 15 (jz_label -> .)
    PRINT           reduce using rule 15 (jz_label -> .)
    PRINTLN         reduce using rule 15 (jz_label -> .)
    WHILE           reduce using rule 15 (jz_label -> .)
    IF              reduce using rule 15 (jz_label -> .)
    ID              reduce using rule 15 (jz_label -> .)
    RETURN          reduce using rule 15 (jz_label -> .)
    INPUT           reduce using rule 15 (jz_label -> .)
    STRINGTYPE      reduce using rule 15 (jz_label -> .)
    INTTYPE         reduce using rule 15 (jz_label -> .)
    FLOATTYPE       reduce using rule 15 (jz_label -> .)
    !               reduce using rule 15 (jz_label -> .)
    -               reduce using rule 15 (jz_label -> .)
    STRING          reduce using rule 15 (jz_label -> .)
    NUM             reduce using rule 15 (jz_label -> .)
    FLOAT           reduce using rule 15 (jz_label -> .)
    (               reduce using rule 15 (jz_label -> .)

    jz_label                       shift and go to state 161

state 160

    (72) block -> { stmtlist } .

    ELSE            reduce using rule 72 (block -> { stmtlist } .)
    PRINT           reduce using rule 72 (block -> { stmtlist } .)
    PRINTLN         reduce using rule 72 (block -> { stmtlist } .)
    WHILE           reduce using rule 72 (block -> { stmtlist } .)
    IF              reduce using rule 72 (block -> { stmtlist } .)
    ID              reduce using rule 72 (block -> { stmtlist } .)
    RETURN          reduce using rule 72 (block -> { stmtlist } .)
    INPUT           reduce using rule 72 (block -> { stmtlist } .)
    STRINGTYPE      reduce using rule 72 (block -> { stmtlist } .)
    INTTYPE         reduce using rule 72 (block -> { stmtlist } .)
    FLOATTYPE       reduce using rule 72 (block -> { stmtlist } .)
    !               reduce using rule 72 (block -> { stmtlist } .)
    -               reduce using rule 72 (block -> { stmtlist } .)
    STRING          reduce using rule 72 (block -> { stmtlist } .)
    NUM             reduce using rule 72 (block -> { stmtlist } .)
    FLOAT           reduce using rule 72 (block -> { stmtlist } .)
    (               reduce using rule 72 (block -> { stmtlist } .)
    $end            reduce using rule 72 (block -> { stmtlist } .)
    }               reduce using rule 72 (block -> { stmtlist } .)


state 161

    (12) stmt -> IF ( expr ) jz block ELSE jmp jz_label . block
    (72) block -> . { stmtlist }
    (73) block -> . stmt
    (7) stmt -> . PRINT ( expr ) ;
    (8) stmt -> . PRINTLN ( ) ;
    (9) stmt -> . PRINTLN ( expr ) ;
    (10) stmt -> . WHILE new_label ( expr ) jz block
    (11) stmt -> . IF ( expr ) jz block
    (12) stmt -> . IF ( expr ) jz block ELSE jmp jz_label block
    (21) stmt -> . ID = expr ;
    (22) stmt -> . expr [ expr ] = expr ;
    (23) stmt -> . RETURN expr ;
    (24) stmt -> . RETURN ;
    (25) stmt -> . expr ;
    (26) expr -> . INPUT ( )
    (27) expr -> . STRINGTYPE ( expr )
    (28) expr -> . INTTYPE ( expr )
    (29) expr -> . FLOATTYPE ( expr )
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr GTE expr
    (37) expr -> . expr LTE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr % expr
    (41) expr -> . expr AND expr
    (42) expr -> . expr OR expr
    (43) expr -> . expr $ expr
    (44) expr -> . ! expr
    (45) expr -> . - expr
    (46) expr -> . ID
    (47) expr -> . expr [ expr ]
    (48) expr -> . STRING
    (49) expr -> . NUM
    (50) expr -> . FLOAT
    (51) expr -> . ID ( fcall )
    (52) expr -> . ( expr )

    {               shift and go to state 150
    PRINT           shift and go to state 25
    PRINTLN         shift and go to state 28
    WHILE           shift and go to state 29
    IF              shift and go to state 30
    ID              shift and go to state 31
    RETURN          shift and go to state 32
    INPUT           shift and go to state 33
    STRINGTYPE      shift and go to state 34
    INTTYPE         shift and go to state 35
    FLOATTYPE       shift and go to state 36
    !               shift and go to state 38
    -               shift and go to state 37
    STRING          shift and go to state 39
    NUM             shift and go to state 40
    FLOAT           shift and go to state 41
    (               shift and go to state 26

    expr                           shift and go to state 27
    block                          shift and go to state 162
    stmt                           shift and go to state 151

state 162

    (12) stmt -> IF ( expr ) jz block ELSE jmp jz_label block .

    PRINT           reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    PRINTLN         reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    WHILE           reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    IF              reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ID              reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    RETURN          reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    INPUT           reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    STRINGTYPE      reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    INTTYPE         reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    FLOATTYPE       reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    !               reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    -               reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    STRING          reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    NUM             reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    FLOAT           reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    (               reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    $end            reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    ELSE            reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)
    }               reduce using rule 12 (stmt -> IF ( expr ) jz block ELSE jmp jz_label block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 149 resolved as shift
